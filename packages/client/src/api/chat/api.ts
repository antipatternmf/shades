/* tslint:disable */
/* eslint-disable */
/**
 * Swagger
 * Web middle chats API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base'

/**
 *
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
  /**
   * Error message
   * @type {string}
   * @memberof BadRequestError
   */
  reason: string
}
/**
 *
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
  /**
   * Old password
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  oldPassword: string
  /**
   * New password
   * @type {string}
   * @memberof ChangePasswordRequest
   */
  newPassword: string
}
/**
 *
 * @export
 * @interface ChartSchemaInner
 */
export interface ChartSchemaInner {
  /**
   * X axis (datetime)
   * @type {string}
   * @memberof ChartSchemaInner
   */
  x?: string
  /**
   *
   * @type {number}
   * @memberof ChartSchemaInner
   */
  y1?: number
  /**
   *
   * @type {number}
   * @memberof ChartSchemaInner
   */
  y2?: number
}
/**
 *
 * @export
 * @interface ChatArchiveRequest
 */
export interface ChatArchiveRequest {
  /**
   * Chat id
   * @type {number}
   * @memberof ChatArchiveRequest
   */
  chatId: number
}
/**
 *
 * @export
 * @interface ChatArchiveResponse
 */
export interface ChatArchiveResponse {
  /**
   * User id
   * @type {number}
   * @memberof ChatArchiveResponse
   */
  userId: number
  /**
   *
   * @type {ChatsResponse}
   * @memberof ChatArchiveResponse
   */
  result: ChatsResponse
}
/**
 *
 * @export
 * @interface ChatDeleteRequest
 */
export interface ChatDeleteRequest {
  /**
   * Chat id
   * @type {number}
   * @memberof ChatDeleteRequest
   */
  chatId: number
}
/**
 *
 * @export
 * @interface ChatDeleteResponse
 */
export interface ChatDeleteResponse {
  /**
   * User id
   * @type {number}
   * @memberof ChatDeleteResponse
   */
  userId: number
  /**
   *
   * @type {ChatsResponse}
   * @memberof ChatDeleteResponse
   */
  result: ChatsResponse
}
/**
 *
 * @export
 * @interface ChatMessage
 */
export interface ChatMessage {
  /**
   * Message id
   * @type {number}
   * @memberof ChatMessage
   */
  id: number
  /**
   * User id
   * @type {number}
   * @memberof ChatMessage
   */
  user_id: number
  /**
   * Chat id
   * @type {number}
   * @memberof ChatMessage
   */
  chat_id: number
  /**
   * Message sent time
   * @type {string}
   * @memberof ChatMessage
   */
  time: string
  /**
   * Message type
   * @type {string}
   * @memberof ChatMessage
   */
  type: ChatMessageTypeEnum
  /**
   * Message content (message text for messages and resourceId for files)
   * @type {string}
   * @memberof ChatMessage
   */
  content: string
  /**
   *
   * @type {Resource}
   * @memberof ChatMessage
   */
  file?: Resource
}

export const ChatMessageTypeEnum = {
  Message: 'message',
  File: 'file',
} as const

export type ChatMessageTypeEnum =
  typeof ChatMessageTypeEnum[keyof typeof ChatMessageTypeEnum]

/**
 *
 * @export
 * @interface ChatUserResponse
 */
export interface ChatUserResponse {
  /**
   * User id
   * @type {number}
   * @memberof ChatUserResponse
   */
  id: number
  /**
   * First name
   * @type {string}
   * @memberof ChatUserResponse
   */
  first_name: string
  /**
   * Second name
   * @type {string}
   * @memberof ChatUserResponse
   */
  second_name: string
  /**
   * Display name
   * @type {string}
   * @memberof ChatUserResponse
   */
  display_name: string
  /**
   * User login - unique
   * @type {string}
   * @memberof ChatUserResponse
   */
  login: string
  /**
   * Email
   * @type {string}
   * @memberof ChatUserResponse
   */
  email: string
  /**
   * Phone
   * @type {string}
   * @memberof ChatUserResponse
   */
  phone: string
  /**
   * Avatar
   * @type {string}
   * @memberof ChatUserResponse
   */
  avatar: string
  /**
   * User role
   * @type {string}
   * @memberof ChatUserResponse
   */
  role: ChatUserResponseRoleEnum
}

export const ChatUserResponseRoleEnum = {
  Admin: 'admin',
  Regular: 'regular',
} as const

export type ChatUserResponseRoleEnum =
  typeof ChatUserResponseRoleEnum[keyof typeof ChatUserResponseRoleEnum]

/**
 *
 * @export
 * @interface ChatsMessagesTokenResponse
 */
export interface ChatsMessagesTokenResponse {
  /**
   * Token for web socket server
   * @type {string}
   * @memberof ChatsMessagesTokenResponse
   */
  token: string
}
/**
 *
 * @export
 * @interface ChatsResponse
 */
export interface ChatsResponse {
  /**
   * Chat id
   * @type {number}
   * @memberof ChatsResponse
   */
  id: number
  /**
   * Chat title
   * @type {string}
   * @memberof ChatsResponse
   */
  title: string
  /**
   * Chat avatar
   * @type {string}
   * @memberof ChatsResponse
   */
  avatar: string
  /**
   * Number of unread messages in chat for current user
   * @type {number}
   * @memberof ChatsResponse
   */
  unread_count: number
  /**
   *
   * @type {ChatsResponseLastMessage}
   * @memberof ChatsResponse
   */
  last_message: ChatsResponseLastMessage
}
/**
 *
 * @export
 * @interface ChatsResponseLastMessage
 */
export interface ChatsResponseLastMessage {
  /**
   *
   * @type {UserResponse}
   * @memberof ChatsResponseLastMessage
   */
  user?: UserResponse
  /**
   * Message timestamp
   * @type {string}
   * @memberof ChatsResponseLastMessage
   */
  time?: string
  /**
   * Message content
   * @type {string}
   * @memberof ChatsResponseLastMessage
   */
  content?: string
}
/**
 *
 * @export
 * @interface CreateChatRequest
 */
export interface CreateChatRequest {
  /**
   * Chat title
   * @type {string}
   * @memberof CreateChatRequest
   */
  title: string
}
/**
 *
 * @export
 * @interface FindUserRequest
 */
export interface FindUserRequest {
  /**
   * User login (beginning of login)
   * @type {string}
   * @memberof FindUserRequest
   */
  login: string
}
/**
 *
 * @export
 * @interface LeaderboardNewLeaderRequest
 */
export interface LeaderboardNewLeaderRequest {
  /**
   * Leaderboard data object, any type
   * @type {object}
   * @memberof LeaderboardNewLeaderRequest
   */
  data: object
  /**
   * Which field is used to sort (if new value of the field more than old, data is stored)
   * @type {string}
   * @memberof LeaderboardNewLeaderRequest
   */
  ratingFieldName: string
  /**
   * Your team name. Used to make unique leaderboard for each project.
   * @type {string}
   * @memberof LeaderboardNewLeaderRequest
   */
  teamName?: string
}
/**
 *
 * @export
 * @interface LeaderboardRequest
 */
export interface LeaderboardRequest {
  /**
   * Which field is used to sort
   * @type {string}
   * @memberof LeaderboardRequest
   */
  ratingFieldName: string
  /**
   * Used to paginate between pages. If limit is 10, then for the 1st page - cursor=0, for the 2nd page - cursor=10.
   * @type {number}
   * @memberof LeaderboardRequest
   */
  cursor: number
  /**
   * Maximum amount of leaders to return
   * @type {number}
   * @memberof LeaderboardRequest
   */
  limit: number
}
/**
 *
 * @export
 * @interface LiveChartRequest
 */
export interface LiveChartRequest {
  /**
   * Works as a cursor (initial value should be zero, all the next values are taken from the backend response)
   * @type {number}
   * @memberof LiveChartRequest
   */
  next: number
}
/**
 *
 * @export
 * @interface LiveChartResponse
 */
export interface LiveChartResponse {
  /**
   * Used as a cursor (pass this value to the next request)
   * @type {number}
   * @memberof LiveChartResponse
   */
  next?: number
  /**
   *
   * @type {Array<ChartSchemaInner>}
   * @memberof LiveChartResponse
   */
  data?: Array<ChartSchemaInner>
}
/**
 *
 * @export
 * @interface LiveVideoInfoRequest
 */
export interface LiveVideoInfoRequest {
  /**
   * Works as a cursor (iterate + 1 each request)
   * @type {number}
   * @memberof LiveVideoInfoRequest
   */
  iteration: number
}
/**
 *
 * @export
 * @interface OauthSignInRequest
 */
export interface OauthSignInRequest {
  /**
   * User code from Yandex
   * @type {string}
   * @memberof OauthSignInRequest
   */
  code: string
  /**
   * Redirect uri that you are using for oauth
   * @type {string}
   * @memberof OauthSignInRequest
   */
  redirect_uri: string
}
/**
 *
 * @export
 * @interface Resource
 */
export interface Resource {
  /**
   * Message id
   * @type {number}
   * @memberof Resource
   */
  id: number
  /**
   * User id
   * @type {number}
   * @memberof Resource
   */
  user_id: number
  /**
   * Server relative file path
   * @type {string}
   * @memberof Resource
   */
  path: string
  /**
   * Initial file name
   * @type {string}
   * @memberof Resource
   */
  filename: string
  /**
   * File content type (e.g \"image/jpeg\" for .jpg images)
   * @type {string}
   * @memberof Resource
   */
  content_type: string
  /**
   * File size in bytes
   * @type {number}
   * @memberof Resource
   */
  content_size: number
  /**
   * Resource uploading time
   * @type {string}
   * @memberof Resource
   */
  upload_date: string
}
/**
 *
 * @export
 * @interface ServiceId
 */
export interface ServiceId {
  /**
   * Service id
   * @type {string}
   * @memberof ServiceId
   */
  service_id: string
}
/**
 *
 * @export
 * @interface SignInRequest
 */
export interface SignInRequest {
  /**
   * User login
   * @type {string}
   * @memberof SignInRequest
   */
  login: string
  /**
   * Password
   * @type {string}
   * @memberof SignInRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
  /**
   * First name
   * @type {string}
   * @memberof SignUpRequest
   */
  first_name: string
  /**
   * Second name
   * @type {string}
   * @memberof SignUpRequest
   */
  second_name: string
  /**
   * User login - unique
   * @type {string}
   * @memberof SignUpRequest
   */
  login: string
  /**
   * Email /^\\S+@\\S+$/
   * @type {string}
   * @memberof SignUpRequest
   */
  email: string
  /**
   * Password
   * @type {string}
   * @memberof SignUpRequest
   */
  password: string
  /**
   * Phone /^((8|\\+7)[\\- ]?)?(\\(?\\d{3}\\)?[\\- ]?)?[\\d\\- ]{7,10}$/
   * @type {string}
   * @memberof SignUpRequest
   */
  phone: string
}
/**
 *
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
  /**
   * Created User ID
   * @type {number}
   * @memberof SignUpResponse
   */
  id: number
}
/**
 *
 * @export
 * @interface StaticChartRequest
 */
export interface StaticChartRequest {
  /**
   * Number of points in chart (10 / 100 / 1000)
   * @type {string}
   * @memberof StaticChartRequest
   */
  chartSize: StaticChartRequestChartSizeEnum
}

export const StaticChartRequestChartSizeEnum = {
  Small: 'small',
  Medium: 'medium',
  Large: 'large',
} as const

export type StaticChartRequestChartSizeEnum =
  typeof StaticChartRequestChartSizeEnum[keyof typeof StaticChartRequestChartSizeEnum]

/**
 *
 * @export
 * @interface StaticChartResponse
 */
export interface StaticChartResponse {
  /**
   *
   * @type {Array<ChartSchemaInner>}
   * @memberof StaticChartResponse
   */
  data?: Array<ChartSchemaInner>
}
/**
 *
 * @export
 * @interface Sticker
 */
export interface Sticker {
  /**
   * Sticker id (send to chat with WS)
   * @type {number}
   * @memberof Sticker
   */
  id?: number
  /**
   * Url for sticker resource(image)
   * @type {string}
   * @memberof Sticker
   */
  path?: string
}
/**
 *
 * @export
 * @interface StickerPack
 */
export interface StickerPack {
  /**
   * Sticker pack title
   * @type {string}
   * @memberof StickerPack
   */
  title?: string
  /**
   * User id that created this pack
   * @type {number}
   * @memberof StickerPack
   */
  user_id?: number
  /**
   *
   * @type {Array<string>}
   * @memberof StickerPack
   */
  stickers?: Array<string>
}
/**
 *
 * @export
 * @interface StickerPacksResponse
 */
export interface StickerPacksResponse {
  /**
   * StickerPacks
   * @type {Array<StickerPack>}
   * @memberof StickerPacksResponse
   */
  data?: Array<StickerPack>
}
/**
 *
 * @export
 * @interface StickersResponse
 */
export interface StickersResponse {
  /**
   * Stickers
   * @type {Array<Sticker>}
   * @memberof StickersResponse
   */
  data?: Array<Sticker>
}
/**
 *
 * @export
 * @interface UnreadCountResponse
 */
export interface UnreadCountResponse {
  /**
   * New messages count
   * @type {number}
   * @memberof UnreadCountResponse
   */
  unread_count: number
}
/**
 *
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
  /**
   * First name
   * @type {string}
   * @memberof UserRequest
   */
  first_name: string
  /**
   * Second name
   * @type {string}
   * @memberof UserRequest
   */
  second_name: string
  /**
   * Display Name
   * @type {string}
   * @memberof UserRequest
   */
  display_name: string
  /**
   * User login - unique
   * @type {string}
   * @memberof UserRequest
   */
  login: string
  /**
   * Email
   * @type {string}
   * @memberof UserRequest
   */
  email: string
  /**
   * Phone
   * @type {string}
   * @memberof UserRequest
   */
  phone: string
}
/**
 *
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
  /**
   * User id
   * @type {number}
   * @memberof UserResponse
   */
  id: number
  /**
   * First name
   * @type {string}
   * @memberof UserResponse
   */
  first_name: string
  /**
   * Second name
   * @type {string}
   * @memberof UserResponse
   */
  second_name: string
  /**
   * Display name
   * @type {string}
   * @memberof UserResponse
   */
  display_name: string
  /**
   * User login - unique
   * @type {string}
   * @memberof UserResponse
   */
  login: string
  /**
   * Email
   * @type {string}
   * @memberof UserResponse
   */
  email: string
  /**
   * Phone
   * @type {string}
   * @memberof UserResponse
   */
  phone: string
  /**
   * Avatar
   * @type {string}
   * @memberof UserResponse
   */
  avatar: string
}
/**
 *
 * @export
 * @interface UserUpdateRequest
 */
export interface UserUpdateRequest {
  /**
   * First name
   * @type {string}
   * @memberof UserUpdateRequest
   */
  first_name: string
  /**
   * Second name
   * @type {string}
   * @memberof UserUpdateRequest
   */
  second_name: string
  /**
   * Display Name
   * @type {string}
   * @memberof UserUpdateRequest
   */
  display_name: string
  /**
   * User login - unique
   * @type {string}
   * @memberof UserUpdateRequest
   */
  login: string
  /**
   * Email
   * @type {string}
   * @memberof UserUpdateRequest
   */
  email: string
  /**
   * Phone
   * @type {string}
   * @memberof UserUpdateRequest
   */
  phone: string
}
/**
 *
 * @export
 * @interface UsersRequest
 */
export interface UsersRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof UsersRequest
   */
  users: Array<number>
  /**
   * Chat id
   * @type {number}
   * @memberof UsersRequest
   */
  chatId: number
}
/**
 *
 * @export
 * @interface VideoInfoResponse
 */
export interface VideoInfoResponse {
  /**
   * Video size in bytes
   * @type {number}
   * @memberof VideoInfoResponse
   */
  size: number
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLogoutPost: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Sign in
     * @param {SignInRequest} signInRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authSigninPost: async (
      signInRequest: SignInRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signInRequest' is not null or undefined
      assertParamExists('authSigninPost', 'signInRequest', signInRequest)
      const localVarPath = `/auth/signin`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signInRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Sign up (create user)
     * @param {SignUpRequest} signUpRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authSignupPost: async (
      signUpRequest: SignUpRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signUpRequest' is not null or undefined
      assertParamExists('authSignupPost', 'signUpRequest', signUpRequest)
      const localVarPath = `/auth/signup`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signUpRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/auth/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authLogoutPost(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Sign in
     * @param {SignInRequest} signInRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authSigninPost(
      signInRequest: SignInRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authSigninPost(
        signInRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Sign up (create user)
     * @param {SignUpRequest} signUpRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authSignupPost(
      signUpRequest: SignUpRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authSignupPost(
        signUpRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async authUserGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.authUserGet(
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authLogoutPost(options?: any): AxiosPromise<void> {
      return localVarFp
        .authLogoutPost(options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Sign in
     * @param {SignInRequest} signInRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authSigninPost(
      signInRequest: SignInRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .authSigninPost(signInRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Sign up (create user)
     * @param {SignUpRequest} signUpRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authSignupPost(
      signUpRequest: SignUpRequest,
      options?: any
    ): AxiosPromise<SignUpResponse> {
      return localVarFp
        .authSignupPost(signUpRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get user info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authUserGet(options?: any): AxiosPromise<UserResponse> {
      return localVarFp
        .authUserGet(options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   *
   * @summary Logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authLogoutPost(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authLogoutPost(options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Sign in
   * @param {SignInRequest} signInRequest User data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authSigninPost(
    signInRequest: SignInRequest,
    options?: AxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .authSigninPost(signInRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Sign up (create user)
   * @param {SignUpRequest} signUpRequest User data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authSignupPost(
    signUpRequest: SignUpRequest,
    options?: AxiosRequestConfig
  ) {
    return AuthApiFp(this.configuration)
      .authSignupPost(signUpRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get user info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public authUserGet(options?: AxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .authUserGet(options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ChartsApi - axios parameter creator
 * @export
 */
export const ChartsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {LiveChartRequest} next next (cursor)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chartsLivePost: async (
      next: LiveChartRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'next' is not null or undefined
      assertParamExists('chartsLivePost', 'next', next)
      const localVarPath = `/charts/live`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        next,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {StaticChartRequest} chartSize chart size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chartsStaticPost: async (
      chartSize: StaticChartRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chartSize' is not null or undefined
      assertParamExists('chartsStaticPost', 'chartSize', chartSize)
      const localVarPath = `/charts/static`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        chartSize,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ChartsApi - functional programming interface
 * @export
 */
export const ChartsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChartsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {LiveChartRequest} next next (cursor)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chartsLivePost(
      next: LiveChartRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<LiveChartResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chartsLivePost(
        next,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {StaticChartRequest} chartSize chart size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chartsStaticPost(
      chartSize: StaticChartRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StaticChartResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chartsStaticPost(chartSize, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ChartsApi - factory interface
 * @export
 */
export const ChartsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ChartsApiFp(configuration)
  return {
    /**
     *
     * @param {LiveChartRequest} next next (cursor)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chartsLivePost(
      next: LiveChartRequest,
      options?: any
    ): AxiosPromise<LiveChartResponse> {
      return localVarFp
        .chartsLivePost(next, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {StaticChartRequest} chartSize chart size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chartsStaticPost(
      chartSize: StaticChartRequest,
      options?: any
    ): AxiosPromise<StaticChartResponse> {
      return localVarFp
        .chartsStaticPost(chartSize, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * ChartsApi - object-oriented interface
 * @export
 * @class ChartsApi
 * @extends {BaseAPI}
 */
export class ChartsApi extends BaseAPI {
  /**
   *
   * @param {LiveChartRequest} next next (cursor)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChartsApi
   */
  public chartsLivePost(next: LiveChartRequest, options?: AxiosRequestConfig) {
    return ChartsApiFp(this.configuration)
      .chartsLivePost(next, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {StaticChartRequest} chartSize chart size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChartsApi
   */
  public chartsStaticPost(
    chartSize: StaticChartRequest,
    options?: AxiosRequestConfig
  ) {
    return ChartsApiFp(this.configuration)
      .chartsStaticPost(chartSize, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get archived chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchiveGet: async (
      offset?: number,
      limit?: number,
      title?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/chats/archive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Archive chat
     * @summary Archive chat by ID
     * @param {ChatArchiveRequest} archiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchivePost: async (
      archiveChatRequest: ChatArchiveRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'archiveChatRequest' is not null or undefined
      assertParamExists(
        'chatsArchivePost',
        'archiveChatRequest',
        archiveChatRequest
      )
      const localVarPath = `/chats/archive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        archiveChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Upload chat avatar
     * @param {number} chatId Chat id
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsAvatarPut: async (
      chatId: number,
      avatar: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chatId' is not null or undefined
      assertParamExists('chatsAvatarPut', 'chatId', chatId)
      // verify required parameter 'avatar' is not null or undefined
      assertParamExists('chatsAvatarPut', 'avatar', avatar)
      const localVarPath = `/chats/avatar`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      if (chatId !== undefined) {
        localVarFormParams.append('chatId', chatId as any)
      }

      if (avatar !== undefined) {
        localVarFormParams.append('avatar', avatar as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete works only for admin role.
     * @summary Delete chat by ID
     * @param {ChatDeleteRequest} deleteChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsDelete: async (
      deleteChatRequest: ChatDeleteRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteChatRequest' is not null or undefined
      assertParamExists('chatsDelete', 'deleteChatRequest', deleteChatRequest)
      const localVarPath = `/chats`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsGet: async (
      offset?: number,
      limit?: number,
      title?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/chats`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get common chat with current chat user (only works for two users chats)
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdCommonGet: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsIdCommonGet', 'id', id)
      const localVarPath = `/chats/{id}/common`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get chat sent files
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdFilesGet: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsIdFilesGet', 'id', id)
      const localVarPath = `/chats/{id}/files`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
     * @param {string} [email] User\&#39;s email to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdUsersGet: async (
      id: any,
      offset?: number,
      limit?: number,
      name?: string,
      email?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsIdUsersGet', 'id', id)
      const localVarPath = `/chats/{id}/users`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get new messages count
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsNewIdGet: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsNewIdGet', 'id', id)
      const localVarPath = `/chats/new/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create chat
     * @param {CreateChatRequest} createChatRequest Chat data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsPost: async (
      createChatRequest: CreateChatRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChatRequest' is not null or undefined
      assertParamExists('chatsPost', 'createChatRequest', createChatRequest)
      const localVarPath = `/chats`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Request token to connect to messages server
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsTokenIdPost: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsTokenIdPost', 'id', id)
      const localVarPath = `/chats/token/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * UnArchive chat
     * @summary UnArchive chat by ID
     * @param {ChatArchiveRequest} unarchiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUnarchivePost: async (
      unarchiveChatRequest: ChatArchiveRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'unarchiveChatRequest' is not null or undefined
      assertParamExists(
        'chatsUnarchivePost',
        'unarchiveChatRequest',
        unarchiveChatRequest
      )
      const localVarPath = `/chats/unarchive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        unarchiveChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete users from chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersDelete: async (
      usersRequest: UsersRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'usersRequest' is not null or undefined
      assertParamExists('chatsUsersDelete', 'usersRequest', usersRequest)
      const localVarPath = `/chats/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        usersRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Add users to chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersPut: async (
      usersRequest: UsersRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'usersRequest' is not null or undefined
      assertParamExists('chatsUsersPut', 'usersRequest', usersRequest)
      const localVarPath = `/chats/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        usersRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get archived chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsArchiveGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsArchiveGet(
        offset,
        limit,
        title,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Archive chat
     * @summary Archive chat by ID
     * @param {ChatArchiveRequest} archiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsArchivePost(
      archiveChatRequest: ChatArchiveRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ChatArchiveResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsArchivePost(
          archiveChatRequest,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Upload chat avatar
     * @param {number} chatId Chat id
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsAvatarPut(
      chatId: number,
      avatar: File,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsAvatarPut(
        chatId,
        avatar,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete works only for admin role.
     * @summary Delete chat by ID
     * @param {ChatDeleteRequest} deleteChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsDelete(
      deleteChatRequest: ChatDeleteRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ChatDeleteResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsDelete(
        deleteChatRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(
        offset,
        limit,
        title,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get common chat with current chat user (only works for two users chats)
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsIdCommonGet(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsIdCommonGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get chat sent files
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsIdFilesGet(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatMessage>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdFilesGet(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
     * @param {string} [email] User\&#39;s email to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsIdUsersGet(
      id: any,
      offset?: number,
      limit?: number,
      name?: string,
      email?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatUserResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdUsersGet(
        id,
        offset,
        limit,
        name,
        email,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get new messages count
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsNewIdGet(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UnreadCountResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsNewIdGet(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Create chat
     * @param {CreateChatRequest} createChatRequest Chat data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsPost(
      createChatRequest: CreateChatRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPost(
        createChatRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Request token to connect to messages server
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsTokenIdPost(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsMessagesTokenResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsTokenIdPost(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * UnArchive chat
     * @summary UnArchive chat by ID
     * @param {ChatArchiveRequest} unarchiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsUnarchivePost(
      unarchiveChatRequest: ChatArchiveRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ChatArchiveResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsUnarchivePost(
          unarchiveChatRequest,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Delete users from chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsUsersDelete(
      usersRequest: UsersRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsUsersDelete(usersRequest, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Add users to chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsUsersPut(
      usersRequest: UsersRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsUsersPut(
        usersRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ChatsApiFp(configuration)
  return {
    /**
     *
     * @summary Get archived chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchiveGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: any
    ): AxiosPromise<Array<ChatsResponse>> {
      return localVarFp
        .chatsArchiveGet(offset, limit, title, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Archive chat
     * @summary Archive chat by ID
     * @param {ChatArchiveRequest} archiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchivePost(
      archiveChatRequest: ChatArchiveRequest,
      options?: any
    ): AxiosPromise<ChatArchiveResponse> {
      return localVarFp
        .chatsArchivePost(archiveChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Upload chat avatar
     * @param {number} chatId Chat id
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsAvatarPut(
      chatId: number,
      avatar: File,
      options?: any
    ): AxiosPromise<ChatsResponse> {
      return localVarFp
        .chatsAvatarPut(chatId, avatar, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Delete works only for admin role.
     * @summary Delete chat by ID
     * @param {ChatDeleteRequest} deleteChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsDelete(
      deleteChatRequest: ChatDeleteRequest,
      options?: any
    ): AxiosPromise<ChatDeleteResponse> {
      return localVarFp
        .chatsDelete(deleteChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: any
    ): AxiosPromise<Array<ChatsResponse>> {
      return localVarFp
        .chatsGet(offset, limit, title, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get common chat with current chat user (only works for two users chats)
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdCommonGet(
      id: any,
      options?: any
    ): AxiosPromise<Array<ChatsResponse>> {
      return localVarFp
        .chatsIdCommonGet(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get chat sent files
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdFilesGet(id: any, options?: any): AxiosPromise<Array<ChatMessage>> {
      return localVarFp
        .chatsIdFilesGet(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
     * @param {string} [email] User\&#39;s email to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdUsersGet(
      id: any,
      offset?: number,
      limit?: number,
      name?: string,
      email?: string,
      options?: any
    ): AxiosPromise<Array<ChatUserResponse>> {
      return localVarFp
        .chatsIdUsersGet(id, offset, limit, name, email, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get new messages count
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsNewIdGet(id: any, options?: any): AxiosPromise<UnreadCountResponse> {
      return localVarFp
        .chatsNewIdGet(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create chat
     * @param {CreateChatRequest} createChatRequest Chat data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsPost(
      createChatRequest: CreateChatRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .chatsPost(createChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Request token to connect to messages server
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsTokenIdPost(
      id: any,
      options?: any
    ): AxiosPromise<Array<ChatsMessagesTokenResponse>> {
      return localVarFp
        .chatsTokenIdPost(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     * UnArchive chat
     * @summary UnArchive chat by ID
     * @param {ChatArchiveRequest} unarchiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUnarchivePost(
      unarchiveChatRequest: ChatArchiveRequest,
      options?: any
    ): AxiosPromise<ChatArchiveResponse> {
      return localVarFp
        .chatsUnarchivePost(unarchiveChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Delete users from chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersDelete(
      usersRequest: UsersRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .chatsUsersDelete(usersRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Add users to chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersPut(
      usersRequest: UsersRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .chatsUsersPut(usersRequest, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI {
  /**
   *
   * @summary Get archived chats
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Chat\&#39;s title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsArchiveGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsArchiveGet(offset, limit, title, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Archive chat
   * @summary Archive chat by ID
   * @param {ChatArchiveRequest} archiveChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsArchivePost(
    archiveChatRequest: ChatArchiveRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsArchivePost(archiveChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Upload chat avatar
   * @param {number} chatId Chat id
   * @param {File} avatar Avatar
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsAvatarPut(
    chatId: number,
    avatar: File,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsAvatarPut(chatId, avatar, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Delete works only for admin role.
   * @summary Delete chat by ID
   * @param {ChatDeleteRequest} deleteChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsDelete(
    deleteChatRequest: ChatDeleteRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsDelete(deleteChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get chats
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Chat\&#39;s title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsGet(offset, limit, title, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get common chat with current chat user (only works for two users chats)
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsIdCommonGet(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsIdCommonGet(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get chat sent files
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsIdFilesGet(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsIdFilesGet(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get chat users
   * @param {any} id Numeric chat id
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
   * @param {string} [email] User\&#39;s email to filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsIdUsersGet(
    id: any,
    offset?: number,
    limit?: number,
    name?: string,
    email?: string,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsIdUsersGet(id, offset, limit, name, email, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get new messages count
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsNewIdGet(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsNewIdGet(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create chat
   * @param {CreateChatRequest} createChatRequest Chat data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsPost(
    createChatRequest: CreateChatRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsPost(createChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Request token to connect to messages server
   * @summary Get chat users
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsTokenIdPost(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsTokenIdPost(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * UnArchive chat
   * @summary UnArchive chat by ID
   * @param {ChatArchiveRequest} unarchiveChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsUnarchivePost(
    unarchiveChatRequest: ChatArchiveRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsUnarchivePost(unarchiveChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete users from chat
   * @param {UsersRequest} usersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsUsersDelete(
    usersRequest: UsersRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsUsersDelete(usersRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Add users to chat
   * @param {UsersRequest} usersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsUsersPut(
    usersRequest: UsersRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsUsersPut(usersRequest, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * LeaderboardApi - axios parameter creator
 * @export
 */
export const LeaderboardApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get all leaderboard
     * @param {LeaderboardRequest} leaderboardRequest Leaderboard request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardAllPost: async (
      leaderboardRequest: LeaderboardRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'leaderboardRequest' is not null or undefined
      assertParamExists(
        'leaderboardAllPost',
        'leaderboardRequest',
        leaderboardRequest
      )
      const localVarPath = `/leaderboard/all`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        leaderboardRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Add user to leaderboard
     * @param {LeaderboardNewLeaderRequest} leaderboardNewLeaderRequest Leader data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardPost: async (
      leaderboardNewLeaderRequest: LeaderboardNewLeaderRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'leaderboardNewLeaderRequest' is not null or undefined
      assertParamExists(
        'leaderboardPost',
        'leaderboardNewLeaderRequest',
        leaderboardNewLeaderRequest
      )
      const localVarPath = `/leaderboard`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        leaderboardNewLeaderRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get team leaderboard
     * @param {any} teamName Name of the team, which leaderboard you want to get
     * @param {LeaderboardRequest} leaderboardRequest Leaderboard request. Cursor is used for pagination. If limit is 10, then for the 1st page - cursor&#x3D;0, for the 2nd page - cursor&#x3D;10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardTeamNamePost: async (
      teamName: any,
      leaderboardRequest: LeaderboardRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'teamName' is not null or undefined
      assertParamExists('leaderboardTeamNamePost', 'teamName', teamName)
      // verify required parameter 'leaderboardRequest' is not null or undefined
      assertParamExists(
        'leaderboardTeamNamePost',
        'leaderboardRequest',
        leaderboardRequest
      )
      const localVarPath = `/leaderboard/{teamName}`.replace(
        `{${'teamName'}}`,
        encodeURIComponent(String(teamName))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        leaderboardRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    LeaderboardApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get all leaderboard
     * @param {LeaderboardRequest} leaderboardRequest Leaderboard request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async leaderboardAllPost(
      leaderboardRequest: LeaderboardRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.leaderboardAllPost(
          leaderboardRequest,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Add user to leaderboard
     * @param {LeaderboardNewLeaderRequest} leaderboardNewLeaderRequest Leader data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async leaderboardPost(
      leaderboardNewLeaderRequest: LeaderboardNewLeaderRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardPost(
        leaderboardNewLeaderRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get team leaderboard
     * @param {any} teamName Name of the team, which leaderboard you want to get
     * @param {LeaderboardRequest} leaderboardRequest Leaderboard request. Cursor is used for pagination. If limit is 10, then for the 1st page - cursor&#x3D;0, for the 2nd page - cursor&#x3D;10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async leaderboardTeamNamePost(
      teamName: any,
      leaderboardRequest: LeaderboardRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.leaderboardTeamNamePost(
          teamName,
          leaderboardRequest,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LeaderboardApiFp(configuration)
  return {
    /**
     *
     * @summary Get all leaderboard
     * @param {LeaderboardRequest} leaderboardRequest Leaderboard request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardAllPost(
      leaderboardRequest: LeaderboardRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .leaderboardAllPost(leaderboardRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Add user to leaderboard
     * @param {LeaderboardNewLeaderRequest} leaderboardNewLeaderRequest Leader data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardPost(
      leaderboardNewLeaderRequest: LeaderboardNewLeaderRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .leaderboardPost(leaderboardNewLeaderRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get team leaderboard
     * @param {any} teamName Name of the team, which leaderboard you want to get
     * @param {LeaderboardRequest} leaderboardRequest Leaderboard request. Cursor is used for pagination. If limit is 10, then for the 1st page - cursor&#x3D;0, for the 2nd page - cursor&#x3D;10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    leaderboardTeamNamePost(
      teamName: any,
      leaderboardRequest: LeaderboardRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .leaderboardTeamNamePost(teamName, leaderboardRequest, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
  /**
   *
   * @summary Get all leaderboard
   * @param {LeaderboardRequest} leaderboardRequest Leaderboard request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public leaderboardAllPost(
    leaderboardRequest: LeaderboardRequest,
    options?: AxiosRequestConfig
  ) {
    return LeaderboardApiFp(this.configuration)
      .leaderboardAllPost(leaderboardRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Add user to leaderboard
   * @param {LeaderboardNewLeaderRequest} leaderboardNewLeaderRequest Leader data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public leaderboardPost(
    leaderboardNewLeaderRequest: LeaderboardNewLeaderRequest,
    options?: AxiosRequestConfig
  ) {
    return LeaderboardApiFp(this.configuration)
      .leaderboardPost(leaderboardNewLeaderRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get team leaderboard
   * @param {any} teamName Name of the team, which leaderboard you want to get
   * @param {LeaderboardRequest} leaderboardRequest Leaderboard request. Cursor is used for pagination. If limit is 10, then for the 1st page - cursor&#x3D;0, for the 2nd page - cursor&#x3D;10.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LeaderboardApi
   */
  public leaderboardTeamNamePost(
    teamName: any,
    leaderboardRequest: LeaderboardRequest,
    options?: AxiosRequestConfig
  ) {
    return LeaderboardApiFp(this.configuration)
      .leaderboardTeamNamePost(teamName, leaderboardRequest, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * OauthApi - axios parameter creator
 * @export
 */
export const OauthApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Sign in / sign up with yandex
     * @param {OauthSignInRequest} oauthSignInRequest Oauth data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthYandexPost: async (
      oauthSignInRequest: OauthSignInRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'oauthSignInRequest' is not null or undefined
      assertParamExists(
        'oauthYandexPost',
        'oauthSignInRequest',
        oauthSignInRequest
      )
      const localVarPath = `/oauth/yandex`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        oauthSignInRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get service id
     * @param {string} [redirectUri] Redirect uri that you are using for oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthYandexServiceIdGet: async (
      redirectUri?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/oauth/yandex/service-id`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (redirectUri !== undefined) {
        localVarQueryParameter['redirect_uri'] = redirectUri
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OauthApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Sign in / sign up with yandex
     * @param {OauthSignInRequest} oauthSignInRequest Oauth data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthYandexPost(
      oauthSignInRequest: OauthSignInRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.oauthYandexPost(
        oauthSignInRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get service id
     * @param {string} [redirectUri] Redirect uri that you are using for oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async oauthYandexServiceIdGet(
      redirectUri?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceId>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.oauthYandexServiceIdGet(
          redirectUri,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OauthApiFp(configuration)
  return {
    /**
     *
     * @summary Sign in / sign up with yandex
     * @param {OauthSignInRequest} oauthSignInRequest Oauth data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthYandexPost(
      oauthSignInRequest: OauthSignInRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .oauthYandexPost(oauthSignInRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get service id
     * @param {string} [redirectUri] Redirect uri that you are using for oauth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    oauthYandexServiceIdGet(
      redirectUri?: string,
      options?: any
    ): AxiosPromise<ServiceId> {
      return localVarFp
        .oauthYandexServiceIdGet(redirectUri, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI {
  /**
   *
   * @summary Sign in / sign up with yandex
   * @param {OauthSignInRequest} oauthSignInRequest Oauth data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OauthApi
   */
  public oauthYandexPost(
    oauthSignInRequest: OauthSignInRequest,
    options?: AxiosRequestConfig
  ) {
    return OauthApiFp(this.configuration)
      .oauthYandexPost(oauthSignInRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get service id
   * @param {string} [redirectUri] Redirect uri that you are using for oauth
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OauthApi
   */
  public oauthYandexServiceIdGet(
    redirectUri?: string,
    options?: AxiosRequestConfig
  ) {
    return OauthApiFp(this.configuration)
      .oauthYandexServiceIdGet(redirectUri, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Serving static files
     * @param {any} path Path to the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesPathGet: async (
      path: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('resourcesPathGet', 'path', path)
      const localVarPath = `/resources/{path}`.replace(
        `{${'path'}}`,
        encodeURIComponent(String(path))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Upload resource(file) to server
     * @param {File} resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesPost: async (
      resource: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'resource' is not null or undefined
      assertParamExists('resourcesPost', 'resource', resource)
      const localVarPath = `/resources`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      if (resource !== undefined) {
        localVarFormParams.append('resource', resource as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Serving static files
     * @param {any} path Path to the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resourcesPathGet(
      path: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.resourcesPathGet(path, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Upload resource(file) to server
     * @param {File} resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resourcesPost(
      resource: File,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Resource>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resourcesPost(
        resource,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ResourcesApiFp(configuration)
  return {
    /**
     *
     * @summary Serving static files
     * @param {any} path Path to the file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesPathGet(path: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .resourcesPathGet(path, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Upload resource(file) to server
     * @param {File} resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resourcesPost(resource: File, options?: any): AxiosPromise<Resource> {
      return localVarFp
        .resourcesPost(resource, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
  /**
   *
   * @summary Serving static files
   * @param {any} path Path to the file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public resourcesPathGet(path: any, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .resourcesPathGet(path, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Upload resource(file) to server
   * @param {File} resource
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ResourcesApi
   */
  public resourcesPost(resource: File, options?: AxiosRequestConfig) {
    return ResourcesApiFp(this.configuration)
      .resourcesPost(resource, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * StickersApi - axios parameter creator
 * @export
 */
export const StickersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get user\'s favorite sticker packs
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Sticker pack title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersFavoriteGet: async (
      offset?: number,
      limit?: number,
      title?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stickers/favorite`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get sticker packs
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Sticker\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersGet: async (
      offset?: number,
      limit?: number,
      title?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stickers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove pack from favorites
     * @param {any} id Numeric sticker pack id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdFavoriteDelete: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('stickersIdFavoriteDelete', 'id', id)
      const localVarPath = `/stickers/{id}/favorite`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Add pack to favorites
     * @param {any} id Numeric sticker pack id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdFavoritePost: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('stickersIdFavoritePost', 'id', id)
      const localVarPath = `/stickers/{id}/favorite`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get stickers from pack
     * @param {any} id Numeric sticker pack id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdGet: async (
      id: any,
      offset?: number,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('stickersIdGet', 'id', id)
      const localVarPath = `/stickers/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Add more stickers (images) to the pack
     * @param {any} id Numeric sticker pack id
     * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdPost: async (
      id: any,
      resource: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('stickersIdPost', 'id', id)
      // verify required parameter 'resource' is not null or undefined
      assertParamExists('stickersIdPost', 'resource', resource)
      const localVarPath = `/stickers/{id}/`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      if (resource !== undefined) {
        localVarFormParams.append('resource', resource as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create sticker pack
     * @param {string} title Sticker pack title
     * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersPost: async (
      title: string,
      resource: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'title' is not null or undefined
      assertParamExists('stickersPost', 'title', title)
      // verify required parameter 'resource' is not null or undefined
      assertParamExists('stickersPost', 'resource', resource)
      const localVarPath = `/stickers`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      if (title !== undefined) {
        localVarFormParams.append('title', title as any)
      }

      if (resource !== undefined) {
        localVarFormParams.append('resource', resource as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StickersApi - functional programming interface
 * @export
 */
export const StickersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StickersApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get user\'s favorite sticker packs
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Sticker pack title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stickersFavoriteGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<StickerPacksResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.stickersFavoriteGet(
          offset,
          limit,
          title,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get sticker packs
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Sticker\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stickersGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StickerPacksResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stickersGet(
        offset,
        limit,
        title,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Remove pack from favorites
     * @param {any} id Numeric sticker pack id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stickersIdFavoriteDelete(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.stickersIdFavoriteDelete(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Add pack to favorites
     * @param {any} id Numeric sticker pack id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stickersIdFavoritePost(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.stickersIdFavoritePost(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get stickers from pack
     * @param {any} id Numeric sticker pack id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stickersIdGet(
      id: any,
      offset?: number,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<StickersResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stickersIdGet(
        id,
        offset,
        limit,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Add more stickers (images) to the pack
     * @param {any} id Numeric sticker pack id
     * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stickersIdPost(
      id: any,
      resource: File,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stickersIdPost(
        id,
        resource,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Create sticker pack
     * @param {string} title Sticker pack title
     * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stickersPost(
      title: string,
      resource: File,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.stickersPost(
        title,
        resource,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * StickersApi - factory interface
 * @export
 */
export const StickersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StickersApiFp(configuration)
  return {
    /**
     *
     * @summary Get user\'s favorite sticker packs
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Sticker pack title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersFavoriteGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: any
    ): AxiosPromise<StickerPacksResponse> {
      return localVarFp
        .stickersFavoriteGet(offset, limit, title, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get sticker packs
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Sticker\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: any
    ): AxiosPromise<Array<StickerPacksResponse>> {
      return localVarFp
        .stickersGet(offset, limit, title, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Remove pack from favorites
     * @param {any} id Numeric sticker pack id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdFavoriteDelete(id: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .stickersIdFavoriteDelete(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Add pack to favorites
     * @param {any} id Numeric sticker pack id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdFavoritePost(id: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .stickersIdFavoritePost(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get stickers from pack
     * @param {any} id Numeric sticker pack id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdGet(
      id: any,
      offset?: number,
      limit?: number,
      options?: any
    ): AxiosPromise<Array<StickersResponse>> {
      return localVarFp
        .stickersIdGet(id, offset, limit, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Add more stickers (images) to the pack
     * @param {any} id Numeric sticker pack id
     * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersIdPost(id: any, resource: File, options?: any): AxiosPromise<void> {
      return localVarFp
        .stickersIdPost(id, resource, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create sticker pack
     * @param {string} title Sticker pack title
     * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stickersPost(
      title: string,
      resource: File,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .stickersPost(title, resource, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * StickersApi - object-oriented interface
 * @export
 * @class StickersApi
 * @extends {BaseAPI}
 */
export class StickersApi extends BaseAPI {
  /**
   *
   * @summary Get user\'s favorite sticker packs
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Sticker pack title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StickersApi
   */
  public stickersFavoriteGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ) {
    return StickersApiFp(this.configuration)
      .stickersFavoriteGet(offset, limit, title, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get sticker packs
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Sticker\&#39;s title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StickersApi
   */
  public stickersGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ) {
    return StickersApiFp(this.configuration)
      .stickersGet(offset, limit, title, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove pack from favorites
   * @param {any} id Numeric sticker pack id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StickersApi
   */
  public stickersIdFavoriteDelete(id: any, options?: AxiosRequestConfig) {
    return StickersApiFp(this.configuration)
      .stickersIdFavoriteDelete(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Add pack to favorites
   * @param {any} id Numeric sticker pack id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StickersApi
   */
  public stickersIdFavoritePost(id: any, options?: AxiosRequestConfig) {
    return StickersApiFp(this.configuration)
      .stickersIdFavoritePost(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get stickers from pack
   * @param {any} id Numeric sticker pack id
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StickersApi
   */
  public stickersIdGet(
    id: any,
    offset?: number,
    limit?: number,
    options?: AxiosRequestConfig
  ) {
    return StickersApiFp(this.configuration)
      .stickersIdGet(id, offset, limit, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Add more stickers (images) to the pack
   * @param {any} id Numeric sticker pack id
   * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StickersApi
   */
  public stickersIdPost(id: any, resource: File, options?: AxiosRequestConfig) {
    return StickersApiFp(this.configuration)
      .stickersIdPost(id, resource, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create sticker pack
   * @param {string} title Sticker pack title
   * @param {File} resource Sticker image (can be multiple images, just attach multiple files)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StickersApi
   */
  public stickersPost(
    title: string,
    resource: File,
    options?: AxiosRequestConfig
  ) {
    return StickersApiFp(this.configuration)
      .stickersPost(title, resource, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get user by id
     * @param {any} id Numeric user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userIdGet: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userIdGet', 'id', id)
      const localVarPath = `/user/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest Password request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPasswordPut: async (
      changePasswordRequest: ChangePasswordRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'changePasswordRequest' is not null or undefined
      assertParamExists(
        'userPasswordPut',
        'changePasswordRequest',
        changePasswordRequest
      )
      const localVarPath = `/user/password`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        changePasswordRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Change user avatar
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userProfileAvatarPut: async (
      avatar: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'avatar' is not null or undefined
      assertParamExists('userProfileAvatarPut', 'avatar', avatar)
      const localVarPath = `/user/profile/avatar`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      if (avatar !== undefined) {
        localVarFormParams.append('avatar', avatar as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Change user profile
     * @param {UserUpdateRequest} userRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userProfilePut: async (
      userRequest: UserUpdateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userRequest' is not null or undefined
      assertParamExists('userProfilePut', 'userRequest', userRequest)
      const localVarPath = `/user/profile`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search for user by login (max 10)
     * @param {FindUserRequest} findUserRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userSearchPost: async (
      findUserRequest: FindUserRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'findUserRequest' is not null or undefined
      assertParamExists('userSearchPost', 'findUserRequest', findUserRequest)
      const localVarPath = `/user/search`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        findUserRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get user by id
     * @param {any} id Numeric user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userIdGet(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userIdGet(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest Password request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userPasswordPut(
      changePasswordRequest: ChangePasswordRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userPasswordPut(
        changePasswordRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Change user avatar
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userProfileAvatarPut(
      avatar: File,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.userProfileAvatarPut(avatar, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Change user profile
     * @param {UserUpdateRequest} userRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userProfilePut(
      userRequest: UserUpdateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userProfilePut(
        userRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Search for user by login (max 10)
     * @param {FindUserRequest} findUserRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userSearchPost(
      findUserRequest: FindUserRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userSearchPost(
        findUserRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     *
     * @summary Get user by id
     * @param {any} id Numeric user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userIdGet(id: any, options?: any): AxiosPromise<UserResponse> {
      return localVarFp
        .userIdGet(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Change user password
     * @param {ChangePasswordRequest} changePasswordRequest Password request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPasswordPut(
      changePasswordRequest: ChangePasswordRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .userPasswordPut(changePasswordRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Change user avatar
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userProfileAvatarPut(
      avatar: File,
      options?: any
    ): AxiosPromise<UserResponse> {
      return localVarFp
        .userProfileAvatarPut(avatar, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Change user profile
     * @param {UserUpdateRequest} userRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userProfilePut(
      userRequest: UserUpdateRequest,
      options?: any
    ): AxiosPromise<UserResponse> {
      return localVarFp
        .userProfilePut(userRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Search for user by login (max 10)
     * @param {FindUserRequest} findUserRequest User data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userSearchPost(
      findUserRequest: FindUserRequest,
      options?: any
    ): AxiosPromise<Array<UserResponse>> {
      return localVarFp
        .userSearchPost(findUserRequest, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Get user by id
   * @param {any} id Numeric user id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userIdGet(id: any, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .userIdGet(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Change user password
   * @param {ChangePasswordRequest} changePasswordRequest Password request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userPasswordPut(
    changePasswordRequest: ChangePasswordRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .userPasswordPut(changePasswordRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Change user avatar
   * @param {File} avatar Avatar
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userProfileAvatarPut(avatar: File, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .userProfileAvatarPut(avatar, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Change user profile
   * @param {UserUpdateRequest} userRequest User data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userProfilePut(
    userRequest: UserUpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .userProfilePut(userRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search for user by login (max 10)
   * @param {FindUserRequest} findUserRequest User data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public userSearchPost(
    findUserRequest: FindUserRequest,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .userSearchPost(findUserRequest, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * VideosApi - axios parameter creator
 * @export
 */
export const VideosApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Get live video stream (part of the video will depend on the \"start\" bytes of the range
     * @param {any} range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosLiveGet: async (
      range: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'range' is not null or undefined
      assertParamExists('videosLiveGet', 'range', range)
      const localVarPath = `/videos/live`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (range != null) {
        localVarHeaderParameter['Range'] =
          typeof range === 'string' ? range : JSON.stringify(range)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get live full video info (size) --- Increases with each request
     * @param {LiveVideoInfoRequest} iteration iteration (cursor)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosLiveInfoPost: async (
      iteration: LiveVideoInfoRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'iteration' is not null or undefined
      assertParamExists('videosLiveInfoPost', 'iteration', iteration)
      const localVarPath = `/videos/live/info`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        iteration,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get static video stream
     * @param {any} range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosStaticGet: async (
      range: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'range' is not null or undefined
      assertParamExists('videosStaticGet', 'range', range)
      const localVarPath = `/videos/static`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (range != null) {
        localVarHeaderParameter['Range'] =
          typeof range === 'string' ? range : JSON.stringify(range)
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Get static full video info (size)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosStaticInfoGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/videos/static/info`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VideosApi - functional programming interface
 * @export
 */
export const VideosApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VideosApiAxiosParamCreator(configuration)
  return {
    /**
     * Get live video stream (part of the video will depend on the \"start\" bytes of the range
     * @param {any} range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async videosLiveGet(
      range: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.videosLiveGet(
        range,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get live full video info (size) --- Increases with each request
     * @param {LiveVideoInfoRequest} iteration iteration (cursor)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async videosLiveInfoPost(
      iteration: LiveVideoInfoRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.videosLiveInfoPost(iteration, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get static video stream
     * @param {any} range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async videosStaticGet(
      range: any,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.videosStaticGet(
        range,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Get static full video info (size)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async videosStaticInfoGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.videosStaticInfoGet(options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * VideosApi - factory interface
 * @export
 */
export const VideosApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VideosApiFp(configuration)
  return {
    /**
     * Get live video stream (part of the video will depend on the \"start\" bytes of the range
     * @param {any} range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosLiveGet(range: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .videosLiveGet(range, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get live full video info (size) --- Increases with each request
     * @param {LiveVideoInfoRequest} iteration iteration (cursor)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosLiveInfoPost(
      iteration: LiveVideoInfoRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .videosLiveInfoPost(iteration, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get static video stream
     * @param {any} range
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosStaticGet(range: any, options?: any): AxiosPromise<void> {
      return localVarFp
        .videosStaticGet(range, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Get static full video info (size)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    videosStaticInfoGet(options?: any): AxiosPromise<void> {
      return localVarFp
        .videosStaticInfoGet(options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * VideosApi - object-oriented interface
 * @export
 * @class VideosApi
 * @extends {BaseAPI}
 */
export class VideosApi extends BaseAPI {
  /**
   * Get live video stream (part of the video will depend on the \"start\" bytes of the range
   * @param {any} range
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VideosApi
   */
  public videosLiveGet(range: any, options?: AxiosRequestConfig) {
    return VideosApiFp(this.configuration)
      .videosLiveGet(range, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get live full video info (size) --- Increases with each request
   * @param {LiveVideoInfoRequest} iteration iteration (cursor)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VideosApi
   */
  public videosLiveInfoPost(
    iteration: LiveVideoInfoRequest,
    options?: AxiosRequestConfig
  ) {
    return VideosApiFp(this.configuration)
      .videosLiveInfoPost(iteration, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get static video stream
   * @param {any} range
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VideosApi
   */
  public videosStaticGet(range: any, options?: AxiosRequestConfig) {
    return VideosApiFp(this.configuration)
      .videosStaticGet(range, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Get static full video info (size)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VideosApi
   */
  public videosStaticInfoGet(options?: AxiosRequestConfig) {
    return VideosApiFp(this.configuration)
      .videosStaticInfoGet(options)
      .then(request => request(this.axios, this.basePath))
  }
}
