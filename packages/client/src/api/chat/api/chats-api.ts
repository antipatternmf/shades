/* tslint:disable */
/* eslint-disable */
/**
 * Swagger
 * Web middle chats API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from '../configuration'
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from '../common'
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from '../base'
// @ts-ignore
import { BadRequestError } from '../models'
// @ts-ignore
import { ChatArchiveRequest } from '../models'
// @ts-ignore
import { ChatArchiveResponse } from '../models'
// @ts-ignore
import { ChatDeleteRequest } from '../models'
// @ts-ignore
import { ChatDeleteResponse } from '../models'
// @ts-ignore
import { ChatMessage } from '../models'
// @ts-ignore
import { ChatUserResponse } from '../models'
// @ts-ignore
import { ChatsMessagesTokenResponse } from '../models'
// @ts-ignore
import { ChatsResponse } from '../models'
// @ts-ignore
import { CreateChatRequest } from '../models'
// @ts-ignore
import { UnreadCountResponse } from '../models'
// @ts-ignore
import { UsersRequest } from '../models'
/**
 * ChatsApi - axios parameter creator
 * @export
 */
export const ChatsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get archived chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchiveGet: async (
      offset?: number,
      limit?: number,
      title?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/chats/archive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Archive chat
     * @summary Archive chat by ID
     * @param {ChatArchiveRequest} archiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchivePost: async (
      archiveChatRequest: ChatArchiveRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'archiveChatRequest' is not null or undefined
      assertParamExists(
        'chatsArchivePost',
        'archiveChatRequest',
        archiveChatRequest
      )
      const localVarPath = `/chats/archive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        archiveChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Upload chat avatar
     * @param {number} chatId Chat id
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsAvatarPut: async (
      chatId: number,
      avatar: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'chatId' is not null or undefined
      assertParamExists('chatsAvatarPut', 'chatId', chatId)
      // verify required parameter 'avatar' is not null or undefined
      assertParamExists('chatsAvatarPut', 'avatar', avatar)
      const localVarPath = `/chats/avatar`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)()

      if (chatId !== undefined) {
        localVarFormParams.append('chatId', chatId as any)
      }

      if (avatar !== undefined) {
        localVarFormParams.append('avatar', avatar as any)
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Delete works only for admin role.
     * @summary Delete chat by ID
     * @param {ChatDeleteRequest} deleteChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsDelete: async (
      deleteChatRequest: ChatDeleteRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deleteChatRequest' is not null or undefined
      assertParamExists('chatsDelete', 'deleteChatRequest', deleteChatRequest)
      const localVarPath = `/chats`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        deleteChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsGet: async (
      offset?: number,
      limit?: number,
      title?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/chats`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (title !== undefined) {
        localVarQueryParameter['title'] = title
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get common chat with current chat user (only works for two users chats)
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdCommonGet: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsIdCommonGet', 'id', id)
      const localVarPath = `/chats/{id}/common`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get chat sent files
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdFilesGet: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsIdFilesGet', 'id', id)
      const localVarPath = `/chats/{id}/files`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
     * @param {string} [email] User\&#39;s email to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdUsersGet: async (
      id: any,
      offset?: number,
      limit?: number,
      name?: string,
      email?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsIdUsersGet', 'id', id)
      const localVarPath = `/chats/{id}/users`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (email !== undefined) {
        localVarQueryParameter['email'] = email
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get new messages count
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsNewIdGet: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsNewIdGet', 'id', id)
      const localVarPath = `/chats/new/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create chat
     * @param {CreateChatRequest} createChatRequest Chat data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsPost: async (
      createChatRequest: CreateChatRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createChatRequest' is not null or undefined
      assertParamExists('chatsPost', 'createChatRequest', createChatRequest)
      const localVarPath = `/chats`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Request token to connect to messages server
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsTokenIdPost: async (
      id: any,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('chatsTokenIdPost', 'id', id)
      const localVarPath = `/chats/token/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * UnArchive chat
     * @summary UnArchive chat by ID
     * @param {ChatArchiveRequest} unarchiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUnarchivePost: async (
      unarchiveChatRequest: ChatArchiveRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'unarchiveChatRequest' is not null or undefined
      assertParamExists(
        'chatsUnarchivePost',
        'unarchiveChatRequest',
        unarchiveChatRequest
      )
      const localVarPath = `/chats/unarchive`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        unarchiveChatRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete users from chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersDelete: async (
      usersRequest: UsersRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'usersRequest' is not null or undefined
      assertParamExists('chatsUsersDelete', 'usersRequest', usersRequest)
      const localVarPath = `/chats/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        usersRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Add users to chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersPut: async (
      usersRequest: UsersRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'usersRequest' is not null or undefined
      assertParamExists('chatsUsersPut', 'usersRequest', usersRequest)
      const localVarPath = `/chats/users`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        usersRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ChatsApi - functional programming interface
 * @export
 */
export const ChatsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ChatsApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Get archived chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsArchiveGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsArchiveGet(
        offset,
        limit,
        title,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Archive chat
     * @summary Archive chat by ID
     * @param {ChatArchiveRequest} archiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsArchivePost(
      archiveChatRequest: ChatArchiveRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ChatArchiveResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsArchivePost(
          archiveChatRequest,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Upload chat avatar
     * @param {number} chatId Chat id
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsAvatarPut(
      chatId: number,
      avatar: File,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsAvatarPut(
        chatId,
        avatar,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Delete works only for admin role.
     * @summary Delete chat by ID
     * @param {ChatDeleteRequest} deleteChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsDelete(
      deleteChatRequest: ChatDeleteRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ChatDeleteResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsDelete(
        deleteChatRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsGet(
        offset,
        limit,
        title,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get common chat with current chat user (only works for two users chats)
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsIdCommonGet(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsIdCommonGet(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get chat sent files
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsIdFilesGet(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatMessage>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdFilesGet(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
     * @param {string} [email] User\&#39;s email to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsIdUsersGet(
      id: any,
      offset?: number,
      limit?: number,
      name?: string,
      email?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatUserResponse>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsIdUsersGet(
        id,
        offset,
        limit,
        name,
        email,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Get new messages count
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsNewIdGet(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<UnreadCountResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsNewIdGet(
        id,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Create chat
     * @param {CreateChatRequest} createChatRequest Chat data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsPost(
      createChatRequest: CreateChatRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsPost(
        createChatRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * Request token to connect to messages server
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsTokenIdPost(
      id: any,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<ChatsMessagesTokenResponse>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsTokenIdPost(id, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     * UnArchive chat
     * @summary UnArchive chat by ID
     * @param {ChatArchiveRequest} unarchiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsUnarchivePost(
      unarchiveChatRequest: ChatArchiveRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<ChatArchiveResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsUnarchivePost(
          unarchiveChatRequest,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Delete users from chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsUsersDelete(
      usersRequest: UsersRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.chatsUsersDelete(usersRequest, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @summary Add users to chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async chatsUsersPut(
      usersRequest: UsersRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.chatsUsersPut(
        usersRequest,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * ChatsApi - factory interface
 * @export
 */
export const ChatsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ChatsApiFp(configuration)
  return {
    /**
     *
     * @summary Get archived chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchiveGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: any
    ): AxiosPromise<Array<ChatsResponse>> {
      return localVarFp
        .chatsArchiveGet(offset, limit, title, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Archive chat
     * @summary Archive chat by ID
     * @param {ChatArchiveRequest} archiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsArchivePost(
      archiveChatRequest: ChatArchiveRequest,
      options?: any
    ): AxiosPromise<ChatArchiveResponse> {
      return localVarFp
        .chatsArchivePost(archiveChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Upload chat avatar
     * @param {number} chatId Chat id
     * @param {File} avatar Avatar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsAvatarPut(
      chatId: number,
      avatar: File,
      options?: any
    ): AxiosPromise<ChatsResponse> {
      return localVarFp
        .chatsAvatarPut(chatId, avatar, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Delete works only for admin role.
     * @summary Delete chat by ID
     * @param {ChatDeleteRequest} deleteChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsDelete(
      deleteChatRequest: ChatDeleteRequest,
      options?: any
    ): AxiosPromise<ChatDeleteResponse> {
      return localVarFp
        .chatsDelete(deleteChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get chats
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [title] Chat\&#39;s title to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsGet(
      offset?: number,
      limit?: number,
      title?: string,
      options?: any
    ): AxiosPromise<Array<ChatsResponse>> {
      return localVarFp
        .chatsGet(offset, limit, title, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get common chat with current chat user (only works for two users chats)
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdCommonGet(
      id: any,
      options?: any
    ): AxiosPromise<Array<ChatsResponse>> {
      return localVarFp
        .chatsIdCommonGet(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get chat sent files
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdFilesGet(id: any, options?: any): AxiosPromise<Array<ChatMessage>> {
      return localVarFp
        .chatsIdFilesGet(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {number} [offset] The number of items to skip before starting to collect the result set
     * @param {number} [limit] The numbers of items to return
     * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
     * @param {string} [email] User\&#39;s email to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsIdUsersGet(
      id: any,
      offset?: number,
      limit?: number,
      name?: string,
      email?: string,
      options?: any
    ): AxiosPromise<Array<ChatUserResponse>> {
      return localVarFp
        .chatsIdUsersGet(id, offset, limit, name, email, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Get new messages count
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsNewIdGet(id: any, options?: any): AxiosPromise<UnreadCountResponse> {
      return localVarFp
        .chatsNewIdGet(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Create chat
     * @param {CreateChatRequest} createChatRequest Chat data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsPost(
      createChatRequest: CreateChatRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .chatsPost(createChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     * Request token to connect to messages server
     * @summary Get chat users
     * @param {any} id Numeric chat id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsTokenIdPost(
      id: any,
      options?: any
    ): AxiosPromise<Array<ChatsMessagesTokenResponse>> {
      return localVarFp
        .chatsTokenIdPost(id, options)
        .then(request => request(axios, basePath))
    },
    /**
     * UnArchive chat
     * @summary UnArchive chat by ID
     * @param {ChatArchiveRequest} unarchiveChatRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUnarchivePost(
      unarchiveChatRequest: ChatArchiveRequest,
      options?: any
    ): AxiosPromise<ChatArchiveResponse> {
      return localVarFp
        .chatsUnarchivePost(unarchiveChatRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Delete users from chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersDelete(
      usersRequest: UsersRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .chatsUsersDelete(usersRequest, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @summary Add users to chat
     * @param {UsersRequest} usersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    chatsUsersPut(
      usersRequest: UsersRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .chatsUsersPut(usersRequest, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * ChatsApi - interface
 * @export
 * @interface ChatsApi
 */
export interface ChatsApiInterface {
  /**
   *
   * @summary Get archived chats
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Chat\&#39;s title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsArchiveGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<Array<ChatsResponse>>

  /**
   * Archive chat
   * @summary Archive chat by ID
   * @param {ChatArchiveRequest} archiveChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsArchivePost(
    archiveChatRequest: ChatArchiveRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<ChatArchiveResponse>

  /**
   *
   * @summary Upload chat avatar
   * @param {number} chatId Chat id
   * @param {File} avatar Avatar
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsAvatarPut(
    chatId: number,
    avatar: File,
    options?: AxiosRequestConfig
  ): AxiosPromise<ChatsResponse>

  /**
   * Delete works only for admin role.
   * @summary Delete chat by ID
   * @param {ChatDeleteRequest} deleteChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsDelete(
    deleteChatRequest: ChatDeleteRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<ChatDeleteResponse>

  /**
   *
   * @summary Get chats
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Chat\&#39;s title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<Array<ChatsResponse>>

  /**
   *
   * @summary Get common chat with current chat user (only works for two users chats)
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsIdCommonGet(
    id: any,
    options?: AxiosRequestConfig
  ): AxiosPromise<Array<ChatsResponse>>

  /**
   *
   * @summary Get chat sent files
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsIdFilesGet(
    id: any,
    options?: AxiosRequestConfig
  ): AxiosPromise<Array<ChatMessage>>

  /**
   *
   * @summary Get chat users
   * @param {any} id Numeric chat id
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
   * @param {string} [email] User\&#39;s email to filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsIdUsersGet(
    id: any,
    offset?: number,
    limit?: number,
    name?: string,
    email?: string,
    options?: AxiosRequestConfig
  ): AxiosPromise<Array<ChatUserResponse>>

  /**
   *
   * @summary Get new messages count
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsNewIdGet(
    id: any,
    options?: AxiosRequestConfig
  ): AxiosPromise<UnreadCountResponse>

  /**
   *
   * @summary Create chat
   * @param {CreateChatRequest} createChatRequest Chat data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsPost(
    createChatRequest: CreateChatRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<void>

  /**
   * Request token to connect to messages server
   * @summary Get chat users
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsTokenIdPost(
    id: any,
    options?: AxiosRequestConfig
  ): AxiosPromise<Array<ChatsMessagesTokenResponse>>

  /**
   * UnArchive chat
   * @summary UnArchive chat by ID
   * @param {ChatArchiveRequest} unarchiveChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsUnarchivePost(
    unarchiveChatRequest: ChatArchiveRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<ChatArchiveResponse>

  /**
   *
   * @summary Delete users from chat
   * @param {UsersRequest} usersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsUsersDelete(
    usersRequest: UsersRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<void>

  /**
   *
   * @summary Add users to chat
   * @param {UsersRequest} usersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApiInterface
   */
  chatsUsersPut(
    usersRequest: UsersRequest,
    options?: AxiosRequestConfig
  ): AxiosPromise<void>
}

/**
 * ChatsApi - object-oriented interface
 * @export
 * @class ChatsApi
 * @extends {BaseAPI}
 */
export class ChatsApi extends BaseAPI implements ChatsApiInterface {
  /**
   *
   * @summary Get archived chats
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Chat\&#39;s title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsArchiveGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsArchiveGet(offset, limit, title, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Archive chat
   * @summary Archive chat by ID
   * @param {ChatArchiveRequest} archiveChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsArchivePost(
    archiveChatRequest: ChatArchiveRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsArchivePost(archiveChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Upload chat avatar
   * @param {number} chatId Chat id
   * @param {File} avatar Avatar
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsAvatarPut(
    chatId: number,
    avatar: File,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsAvatarPut(chatId, avatar, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Delete works only for admin role.
   * @summary Delete chat by ID
   * @param {ChatDeleteRequest} deleteChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsDelete(
    deleteChatRequest: ChatDeleteRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsDelete(deleteChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get chats
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [title] Chat\&#39;s title to filter by
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsGet(
    offset?: number,
    limit?: number,
    title?: string,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsGet(offset, limit, title, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get common chat with current chat user (only works for two users chats)
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsIdCommonGet(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsIdCommonGet(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get chat sent files
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsIdFilesGet(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsIdFilesGet(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get chat users
   * @param {any} id Numeric chat id
   * @param {number} [offset] The number of items to skip before starting to collect the result set
   * @param {number} [limit] The numbers of items to return
   * @param {string} [name] User\&#39;s \&#39;{first_name} {second_name}\&#39; to filter
   * @param {string} [email] User\&#39;s email to filter
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsIdUsersGet(
    id: any,
    offset?: number,
    limit?: number,
    name?: string,
    email?: string,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsIdUsersGet(id, offset, limit, name, email, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get new messages count
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsNewIdGet(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsNewIdGet(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create chat
   * @param {CreateChatRequest} createChatRequest Chat data
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsPost(
    createChatRequest: CreateChatRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsPost(createChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * Request token to connect to messages server
   * @summary Get chat users
   * @param {any} id Numeric chat id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsTokenIdPost(id: any, options?: AxiosRequestConfig) {
    return ChatsApiFp(this.configuration)
      .chatsTokenIdPost(id, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   * UnArchive chat
   * @summary UnArchive chat by ID
   * @param {ChatArchiveRequest} unarchiveChatRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsUnarchivePost(
    unarchiveChatRequest: ChatArchiveRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsUnarchivePost(unarchiveChatRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete users from chat
   * @param {UsersRequest} usersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsUsersDelete(
    usersRequest: UsersRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsUsersDelete(usersRequest, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Add users to chat
   * @param {UsersRequest} usersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ChatsApi
   */
  public chatsUsersPut(
    usersRequest: UsersRequest,
    options?: AxiosRequestConfig
  ) {
    return ChatsApiFp(this.configuration)
      .chatsUsersPut(usersRequest, options)
      .then(request => request(this.axios, this.basePath))
  }
}
